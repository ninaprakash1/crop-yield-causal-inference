---
title: "Finding Important Covariates"
output: html_notebook
---

```{r}
library(dplyr)       # data wrangling
library(rpart)       # performing regression trees
library(rpart.plot)  # plotting regression trees
library(countrycode)
library(data.table)
library(ggplot2)
```


```{r}
data<-read.csv("data/Data for R.csv", na.strings = "")
```


```{r}
data <- subset(data, Outlier_NT ==0 | Outlier_CT == 0)
```

# Covariate & Treatment Preprocessing

While almost all covariates are constant for a pair, there are a few "covariates" that differ within the pair, all of which are differening management practices, and which thus are more appropriate to be treated as an additional treatment variable. Before defining our covariates and treatments, we first check whether these actually do differ between pairs. 
```{r}
potential_mgmt_practice_treatments <- c("R.CT",
                          "R.NT", 
                          "SC.CT",  
                          "SC.NT",
                          "Rotation.CT",
                          "Rotation.NT",
                          "Residue.Management.in.CT.in.last.cropping.season..available.in.current.cropping.season.",
                          "Residue.Management.in.NT.in.last.cropping.season..available.in.current.cropping.season.", 
                          "Weed.and.pest.control.CT",
                          "Weed.and.pest.control.NT", 
                          "Fertilization.CT", 
                          "Fertilization.NT", 
                          "Irrigation.CT", 
                          "Irrigation.NT"
                          ) 

for (i in seq(1,length(potential_mgmt_practice_treatments),2)){
  all_same <- all(data[,potential_mgmt_practice_treatments[i]] == data[,potential_mgmt_practice_treatments[i+1]], na.rm = TRUE)
  if (all_same) {
    print(potential_mgmt_practice_treatments[i])
  }

}

```

We see that R (Crop Rotation w/ more than 2 conservation crops) and Irrigation are always the same across pairs, so we treat these as covariates, rather than treatments, dropping the duplicated column, and renaming to reflect this change. 
```{r}
 data_clean <- data %>% 
  rename(Rotation.Conservation.Crop = R.CT, Irrigation = Irrigation.CT)
```

We also choose not to include any columns that have more than 50% of values missing. (Of these, only  Cover.crop.before.sowing and Irrigation would have been variables of interest).
```{r}

perc_null <- sapply(X = data_clean, FUN = function(x) sum(is.na(x))/length(x))
print(perc_null[perc_null > .5])
```



## Defining Covariates of Interest
There are various covariates (as well as other additional treatments) of interest that fall into different categories. 
Note that Study id (Seq) is not of interest, but is needed to later identify undesired stratifications containing observations from only a small number of studies. 
```{r}

study_covars <- c('Seq') #id for study 
study_location_covars <- c( "Site.country", 
                            "Latitude",
                            "Longitude")

study_year_covars <- c("Start.year.of.NT...or.first.year.of.experiment.if.missing.", 
                     "Sowing.year",
                     "Harvest.year")

seasonal_covars <- c("Sowing.month", 
                     "Harvesting.month"
                    )

mgmt_practice_treatments <- c("SC.CT",  #categorical: Yes, No or Mixed
                          "SC.NT",
                          "Rotation.CT",# indicator of any crop rotation
                          "Rotation.NT",
                          "Residue.Management.in.CT.in.last.cropping.season..available.in.current.cropping.season.",# categorical: retained, removed or average
                          "Residue.Management.in.NT.in.last.cropping.season..available.in.current.cropping.season.",
                          "Weed.and.pest.control.CT", #indicator
                          "Weed.and.pest.control.NT",
                          "Fertilization.CT", #categorical: Yes, No or Mix
                          "Fertilization.NT",
                          "Durationof.NT.period.at.sowing..yrs." #duration of treatment (in years)
                          ) 


mgmt_practice_covars <- c("Rotation.Conservation.Crop", #indicator of Crop rotation with >= 3 crops in accordance with FAO def of conservation agriculture 
                          "N.input" #Yes, No or Mix
                          ) 

climatic_soil_vars <- c("pH..surface.layer.", #at experiment site at time of experiment start
                        "P", #Precipitation over the growing season	(mm)
                        "E", #Potential evapotranspiration over the growing season (mm))
                        "PB", #Precipitation balance (mm) := the amount of available water in the growing season for rainfed field
                        "Tave", #Average air temperature during the growing season (C)
                        "Tmax", #Max air temperature during the growing season (C) 
                        "Tmin", #Min air temperature during the growing season (C) 
                        "ST") #Soil texture at experiment  location. Categorical: Sandy Loam; Loam; Silt Loam; Sandy Clay Loam; Clay Loam; Sandy Clay; Clay
                        
crop_covar<- c("Crop")
outcome <- c("Ln_ratio")

keep_cols <- c(study_covars,study_location_covars, study_year_covars, seasonal_covars,crop_covar, mgmt_practice_covars, mgmt_practice_treatments, climatic_soil_vars, outcome)
```


```{r}
data_clean<- data_clean[,keep_cols]
```

In 2 cases, experimement year is before sowing year, which is likely a data entry error, so we remove these observation pairs:
```{r}
data_clean <- data_clean[data_clean$Durationof.NT.period.at.sowing..yrs. >= 0,]
```


The ph covariate is currently coded as a string and we need to recode this as numeric, handling cases where string contains a range or other edge cases. 
```{r}
#set ph vars for 22 cases where different for treatment and control to Null (also the one case with a comma, "5,2" since unclear what this means-- likely a typo)
msk<- grepl("CT|NT|,", data_clean$pH..surface.layer.)
print(sum(msk))
data_clean[msk,]$pH..surface.layer. <-''
#remove "with lime application" from end of string in 15 cases
msk<- grepl(" with lime application", data_clean$pH..surface.layer.)
print(sum(msk))
data_clean[msk,]$pH..surface.layer. <- substr(data_clean[msk,]$pH..surface.layer., 1,10)
#remove "or above" from 10 cases where ph var is "\d or above" (treat as \d)
msk<- grepl("above", data_clean$pH..surface.layer.)
print(sum(msk))
data_clean[msk,]$pH..surface.layer. <- gsub("([0-9]+).*", "\\1", data_clean[msk,]$pH..surface.layer.)
# for 164 cases that give a range with "to" or "-": replace "{x1} to/- {x2}" strings with mean of x1 and x2
msk<- grepl("to", data_clean$pH..surface.layer.)
print(sum(msk))
range_strings <- data_clean[msk,]$pH..surface.layer. 
data_clean[msk,]$pH..surface.layer. <- sapply(strsplit(range_strings, split = " to ", fixed = TRUE), function(k) mean(as.numeric(k)))
msk<- grepl("-", data_clean$pH..surface.layer.)
print(sum(msk))
range_strings <- data_clean[msk,]$pH..surface.layer. 
data_clean[msk,]$pH..surface.layer. <- sapply(strsplit(range_strings, split = "-", fixed = TRUE), function(k) mean(as.numeric(k)))
```



Convert character columns to factors and and cleaned pd column to numeric
```{r}
to_factor_cols <- c(c("Seq", "Site.country", "Crop", 'ST'), mgmt_practice_covars)
data_clean[to_factor_cols] <- lapply(data_clean[to_factor_cols], factor)
data_clean$pH..surface.layer. <- as.numeric(data_clean$pH..surface.layer.)

data_covar <- data_clean[, !names(data_clean) %in% mgmt_practice_treatments]
```



The study is by far the best predictor of outcome, which is clearly not of interest to us, and is likely to produce strata that include observations from only a few studies.
```{r}
m1 <- rpart(
  formula = Ln_ratio ~ .,
  data    = data_covar,
  method  = "anova"
  )
print(m1$variable.importance[0:5])
sf_seq_strata <- setNames(data.frame(cbind( m1$where, data_clean$Seq)),  c('strata', 'Seq'))
print(sf_seq_strata %>% group_by(strata) %>% summarise(n_distinct(Seq)))
```

We want to avoid stratifying such that (1) a strata is comprised of observations from a single study, or (2) where stratification splits are based implicitly on the study. 

Since many covariates are almost always the the same across a study, we would expect that a regression tree that includes these covariates will split on these, thus implicitly splitting on study. The following are all more than 90% constant. 

```{r}
n_unique_covar_per_study <- data.table(data_covar)[, lapply(.SD, function(x) length(unique(x))), by=Seq]
perc_studies_with_const_covar <- lapply(n_unique_covar_per_study, function(col) {sum(col == 1)/length(col)})
print(perc_studies_with_const_covar[perc_studies_with_const_covar > .9])
```

Thus to identify these, we fit a decision tree on Seq to identify these variables that are highly predictive of Seq. 
```{r}
m_study <- rpart(
  formula = Seq ~ .,
  data    = data_covar,
  xval = 1,
  method = 'anova'
  )

predictive_of_seq_covars <- names(m_study$variable.importance[0:4])
#predictive_of_seq_covars <- c(predictive_of_seq_covars, c("Sowing.year","Harvest.year"))
print(m_study$variable.importance)

```
Unsurprisingly, the top 4 in terms of variable importance are all variables that are > 90% constant across the studies are included in this list-- We choose to not consider these most predictive covariates. 
```{r}
print(predictive_of_seq_covars)
```

To replace the location information of interest encoded in latitude and longitude, we add climatic zones following (Piltcow et. al) based on latitude, and also continent (related to lat and lon)
```{r}
data_clean$climate_zone <- cut(abs(data_clean$Latitude), breaks = c(0, 23.5, 40, 60, 90), 
                         labels = c("tropical", "subtropical", "temperate", "cold"))
```

```{r}
data_clean$continent <- countrycode(sourcevar = data_clean[, "Site.country"],
                            origin = "country.name",
                            destination = "continent")

data_covar <- data_clean[, !names(data_clean) %in% mgmt_practice_treatments]
```

we check that these are not highly predictive of Study
```{r}
m_study <- rpart(
  formula = Seq ~ .,
  data    = data_covar[,!(names(data_covar) %in% predictive_of_seq_covars)],
  method  = "anova"
  )

print(m_study$variable.importance)

```

```{r}
m2 <- rpart(
  formula = Ln_ratio ~ .,
  data    = data_covar[,!(names(data_covar) %in% c("Seq", predictive_of_seq_covars))],
  #data    = data[,!(names(data) %in% c("Seq"))],
  method  = "anova",
  xval = 10
  )
print(m2$variable.importance[0:5])
sf_seq_strata <- setNames(data.frame(cbind( m2$where, data_covar$Seq)),  c('strata', 'Seq'))
print(sf_seq_strata %>% group_by(strata) %>% summarise(n_distinct(Seq)))
rpart.plot(m2)

```


To simplify these trees to me more interpretable, result in fewer strata, and prevent any strata from being composed of observations from a single study, we set the minimum number of observations per leaf based on the 
the number of observations per paper
```{r}
num_study <- data_clean %>% group_by(Seq) %>% summarise(n = n())
quantile(num_study $n, .9)
quantile(num_study $n, .95)
quantile(num_study $n, .99)
```

use minbucket based on the number of observations per paper and lower complexity parameter
```{r}
m3 <- rpart(
  formula = Ln_ratio ~ .,
  data    = data_covar[,!(names(data_covar) %in% c("Seq", predictive_of_seq_covars))],
  method  = "anova",
  cp = .015,
  minbucket = 37,
  xval = 10
  )
print(m3$variable.importance[0:5])
sf_seq_strata <- setNames(data.frame(cbind( m3$where, data_covar$Seq)),  c('strata', 'Seq'))
print(sf_seq_strata %>% group_by(strata) %>% summarise(n_distinct(Seq)))
rpart.plot(m3)
```


compared to actual statistics of staple crops, maize, rice, and wheat are ranked highest in terms of annual followed by soybeans and sorghum, with the others not making the top 10 list. Our distribution does somewhat follow this distribution, but with rice  underepresented, and barley somewhat overrepresented. Thus our first stratification is roughly based on importance w.r.t annual production. 
Alternatively, 
```{r}
data_clean %>% group_by(Crop) %>%
  summarise(n = n()) %>%
  arrange(desc(n))
```

```{r}
data_clean <- data_clean %>% 
              group_by(Crop) %>%
              mutate(crop_freq = n(),
                     crop_weight = nrow(data_clean)/n()) %>%
              ungroup()

              
```

use minbucket based on the number of observations per paper
```{r}

m4 <- rpart(
  formula = Ln_ratio ~ .,
  data    = data_covar[,!(names(data_covar) %in% c("Seq", predictive_of_seq_covars))],
  method  = "anova",
  cp = .015,
  minbucket = 37,
  weights = data_clean$crop_weight,
  xval = 10
  )
print(m4$variable.importance[0:5])
sf_seq_strata <- setNames(data.frame(cbind( m4$where, data_covar$Seq)),  c('strata', 'Seq'))
print(sf_seq_strata %>% group_by(strata) %>% summarise(n_distinct(Seq)))
rpart.plot(m4)
```




```{r}
# num_study_crop <- data.frame(data %>% 
#     group_by(Crop, Seq) %>% 
#    summarise(n = n()) %>%
#    group_by(Crop) %>% 
#   summarise(q_99 =quantile(n, .99), q_95 = quantile(n, .95), q_90 =quantile(n, .9), n_unique = n()))
# print(num_study_crop)
```

```{r}
crop_list <- c('maize', 'rice', 'wheat')
# crop_list <- unique(data_clean$Crop)
for (crop_name in crop_list) {
  print(crop_name)
  min_bucket = as.integer(num_study_crop$q_95[num_study_crop$Crop == crop_name ])
  crop_mask <- data_covar$Crop == crop_name
  m_crop <- rpart(
    formula = Ln_ratio ~ .,
    data    = data_covar[,!(names(data_covar) %in% c("Seq", predictive_of_seq_covars))][crop_mask,],
    #data    = data[,!(names(data) %in% c("Seq"))],
    method  = "anova",
    minbucket = min_bucket,
     cp = .015,
    xval = 10
    )
  #print(m_crop$variable.importance[0:5])
  sf_seq_strata <- setNames(data.frame(cbind( m_crop$where, data_covar$Seq)),  c('strata', 'Seq'))
  print(sf_seq_strata %>% group_by(strata) %>% summarise(n_distinct(Seq)))
  rpart.plot(m_crop)

}

```


```{r}
df_strata <- setNames(data.frame(cbind( m3$where, data_covar$Ln_ratio)),  c('strata', 'Ln_ratio'))
```



```{r}
(Var.Neyman.Crop <- df_strata %>% group_by(strata) %>%
   dplyr::summarise(
            Mean.Log.Yield.Ratio = mean(Ln_ratio), 
            Var.Log.Yield.Ratio = var(Ln_ratio)/(n()-1),
            n = n()))


Var.Neyman.Crop <- Var.Neyman.Crop %>% 
  mutate(CI.L.Ratio  = Mean.Log.Yield.Ratio - qnorm(.975)*sqrt(Var.Log.Yield.Ratio), 
        CI.U.Ratio  = Mean.Log.Yield.Ratio + qnorm(.975)*sqrt(Var.Log.Yield.Ratio))
```


<!-- ```{r} -->
<!-- (mu= mean(data_clean$Ln_ratio)) -->
<!-- (v = var(data_clean$Ln_ratio)/(nrow(data_clean)-1)) -->
<!-- (CI = c(mu - qnorm(.975)*sqrt(v), mu + qnorm(.975)*sqrt(v))) -->
<!-- ``` -->

```{r}
p2<- ggplot(Var.Neyman.Crop, aes(x=strata, y=Mean.Log.Yield.Ratio)) +
  geom_point( size = 3, color = 'purple') +
  geom_errorbar(aes(ymax = CI.U.Ratio, ymin = CI.L.Ratio), color = 'purple', alpha = .8) +
  coord_flip() +
  xlab("")

p2 + geom_hline(yintercept= 0, color= 'black', linetype = 'dashed', alpha = .8) + 
    ggtitle("95% CI for Log Ratio")
```

```{r}
hist(data_clean$Durationof.NT.period.at.sowing..yrs., breaks = 52)
```


```{r}
dur_max <- max(data_clean$Durationof.NT.period.at.sowing..yrs.)
data_clean<-data_clean %>%
  mutate(treatment_duration = cut(Durationof.NT.period.at.sowing..yrs., 
                                  breaks = c(0,5, 10,20,dur_max), 
                                  include.lowest = TRUE),
         treatment_duration_eq = cut_number(Durationof.NT.period.at.sowing..yrs.,4))
data_clean %>% group_by(treatment_duration) %>% summarise(n = n())
data_clean %>% group_by(treatment_duration_eq) %>% summarise(n = n())
```

```{r}
(Var.Neyman.Crop <- data_clean %>% group_by(treatment_duration_eq, Crop) %>%
   dplyr::summarise(
            Mean.Log.Yield.Ratio = mean(Ln_ratio), 
            Var.Log.Yield.Ratio = var(Ln_ratio)/(n()-1),
            n = n()))


Var.Neyman.Crop <- Var.Neyman.Crop %>% 
  mutate(CI.L.Ratio  = Mean.Log.Yield.Ratio - qnorm(.975)*sqrt(Var.Log.Yield.Ratio), 
        CI.U.Ratio  = Mean.Log.Yield.Ratio + qnorm(.975)*sqrt(Var.Log.Yield.Ratio))
```




```{r}
p2<- ggplot(Var.Neyman.Crop, aes(x=treatment_duration_eq, y=Mean.Log.Yield.Ratio)) +
  geom_point( size = 3, color = 'purple') +
  geom_errorbar(aes(ymax = CI.U.Ratio, ymin = CI.L.Ratio), color = 'purple', alpha = .8) +
  coord_flip() +
  xlab("") +
  facet_wrap(~Crop,ncol = 5,  scales = "free")
  

p2 + geom_hline(yintercept= 0, color= 'black', linetype = 'dashed', alpha = .8) + 
    ggtitle("95% CI for Log Ratio")
```


```{r}
c_treatment <- "Fertilization.CT"
t_treatment <- "Fertilization.NT"
# c_treatment <- "Residue.Management.in.CT.in.last.cropping.season..available.in.current.cropping.season."
# t_treatment <- "Residue.Management.in.NT.in.last.cropping.season..available.in.current.cropping.season."
#binary_treatments <- c("retained", "removed")
binary_treatments <- c("Yes", "No")

data_sub <- data_clean %>% 
  select(.data[[c_treatment]], .data[[t_treatment]], Ln_ratio, Crop) %>%
  filter(.data[[c_treatment]] %in% binary_treatments & .data[[t_treatment]] %in% binary_treatments) %>%
  mutate(treatment_pair = paste(.data[[c_treatment]], .data[[t_treatment]] ))

#data_sub$Fertilization.Pair <- paste(data_clean$Fertilization.CT, data_clean$Fertilization.NT)

data_sub %>% group_by(Crop, treatment_pair) %>% summarise(n = n())
```

```{r}
(Var.Neyman.Crop <- data_sub %>% group_by(treatment_pair, Crop) %>%
   dplyr::summarise(
            Mean.Log.Yield.Ratio = mean(Ln_ratio), 
            Var.Log.Yield.Ratio = var(Ln_ratio)/(n()-1),
            n = n()))


Var.Neyman.Crop <- Var.Neyman.Crop %>% 
  mutate(CI.L.Ratio  = Mean.Log.Yield.Ratio - qnorm(.975)*sqrt(Var.Log.Yield.Ratio), 
        CI.U.Ratio  = Mean.Log.Yield.Ratio + qnorm(.975)*sqrt(Var.Log.Yield.Ratio))
```


```{r}
p2<- ggplot(Var.Neyman.Crop, aes(x=treatment_pair, y=Mean.Log.Yield.Ratio)) +
  geom_point( size = 3, color = 'purple') +
  geom_errorbar(aes(ymax = CI.U.Ratio, ymin = CI.L.Ratio), color = 'purple', alpha = .8) +
  coord_flip() +
  xlab("") + facet_wrap(~Crop,nrow = 5,  scales = "free")
  

p2 + geom_hline(yintercept= 0, color= 'black', linetype = 'dashed', alpha = .8) + 
    ggtitle("95% CI for Log Ratio")
```

